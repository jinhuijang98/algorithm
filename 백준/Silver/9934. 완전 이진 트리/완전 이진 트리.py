# 9934 완전 이진 트리
'''
이 도시의 도로는 깊이가 K인 완전 이진 트리
깊이가 K인 완전이진트리는 2^k-1개의 노드로 이루어짐.
그곳에 위치한 빌딩의 번호가 붙여짐. 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 가짐.

도시에 있는 모든 빌딩에 들어갔고, 들어간 순서대로 번호를 종이에 적어 놓음.
어떤 순서로 도시를 방문했는지 기억해냄.

1. 가장 처음에 상근이는 트리의 루트에 있는 빌딩 앞에 서있음.
2. 현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면, 왼쪽 자식으로 이동.
3. 현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나, 왼쪽 자식에 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌딩을 들어가고 종이에 번호를 적음.
4. 현재 빌딩을 이미 들어갔다 온 상태이고, 오른족 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동
5. 현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동

'''

k = int(input())

inorder = list(map(int, input().split()))


answer = [[] for _ in range(k)]
# 중위 순회를 반대로 실행
# level 이용
# 중위순회 입력된 리스트 가운데가 항상 root 노드임을 활용
# 중위순회로 입력된 리스트를 왼쪽 부분 트리, 오른쪽 부분 트리로 쪼갤 줄 알아야 함.
def dfs(inorder, depth):

    # 트리의 root index를 찾아낸다
    mid = (len(inorder) // 2 )

    # 해당 깊이에 해당하는 node를 추가.
    answer[depth].append(inorder[mid])

    if len(inorder) == 1:
        return

    dfs(inorder[:mid], depth + 1)
    dfs(inorder[mid+1:], depth + 1)


dfs(inorder, 0)

for i in answer:
    print(*i)